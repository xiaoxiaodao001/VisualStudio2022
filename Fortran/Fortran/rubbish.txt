
    ! “00 00:00:00.000”(日 时分秒毫秒), msPart \in [0-24*60*60*1000+1, 24*60*60*1000-1]
    subroutine sub_msPart2PartUsedDateTime(msPart, PartUsedDateTime)
    implicit none
    integer(kind=4), intent(in):: msPart
    integer(kind=4), intent(out):: PartUsedDateTime(5)
    
    integer(kind=4):: DD, hh, mm, ss, ms, temp, absmsPart, msPartMax = 24*60*60*1000
    
    PartUsedDateTime = 0
    if (msPart == 0) then
        return
    else if ((msPart > 0) .and. (msPart < msPartMax)) then
        ms = mod(msPart, 1000)
        PartUsedDateTime(5) = ms
        temp = msPart / 1000
        if (temp == 0) then
            return
        else
            ss = mod(temp, 60)
            PartUsedDateTime(4) = ss
            temp = ss / 60
            if (temp == 0) then
                return
            else
                mm = mod(temp, 60)
                PartUsedDateTime(3) = mm
                temp = temp / 60
                if (temp == 0) then
                    return
                else
                    hh = mod(temp, 24)
                    PartUsedDateTime(2) = hh
                    temp = temp / 24
                    if (temp == 0) then
                        return
                    else
                        dd = temp
                        PartUsedDateTime(1) = dd
                        return
                    end if
                end if
            end if
        end if
    else if ((msPart < 0) .and. (msPart > -msPartMax)) then
        dd = -1        
        PartUsedDateTime(1) = dd
        absmsPart = abs(msPart)
        ms = mod(absmsPart, 1000)
        PartUsedDateTime(5) = ms
        temp = absmsPart / 1000
        if (temp == 0) then
            return
        else
            ss = mod(temp, 60)
            PartUsedDateTime(4) = ss
            temp = ss / 60
            if (temp == 0) then
                return
            else
                mm = mod(temp, 60)
                PartUsedDateTime(3) = mm
                temp = temp / 60
                if (temp == 0) then
                    return
                else
                    hh = mod(temp, 24)
                    PartUsedDateTime(2) = hh
                    temp = temp / 24
                    if (temp == 0) then
                        return
                    else
                        dd = temp
                        PartUsedDateTime(1) = dd
                        return
                    end if
                end if
            end if
        end if

        
    
    
    ! 将时区信息转换为这样的字符串：“+08:00”
    subroutine sub_zone2str(zone, str_zone)
    implicit none
    integer(kind=4), intent(in):: zone
    character(len=6), intent(out):: str_zone
    
    integer(kind=4):: zone_hh, zone_mm, abs_zone
    
    if (zone == 0) then
        str_zone = "+00:00"
    else if(zone > 0) then
        zone_hh = zone / 60
        zone_mm = mod(zone, 60)
        write(str_zone, "('+', i2.2, ':', i2.2)") zone_hh, zone_mm
    else 
        abs_zone = abs(zone)
        zone_hh = abs_zone / 60
        zone_mm = mod(abs_zone, 60)
        write(str_zone, "('-', i2.2, ':', i2.2)") zone_hh, zone_mm
    end if
    
    return
    end subroutine sub_zone2str

        
        
    
    
    ! 利用date_and_time([date,time,zone,values])中的values(1:8)计算所用时间
    subroutine sub_msUsedTime(DateTime1, DateTime2, msUsedTime)
    implicit none
    integer(kind=4), intent(in):: DateTime1(8), DateTime2(8)
    integer(kind=8), intent(out):: msUsedTime
    
    integer(kind=4):: UTCtime1(8), UTCtime2(8)
    integer(kind=8):: msTime1, msTime2
    
    msUsedTime = 0
    if (all(DateTime1 == DateTime2)) return
    
    call sub_Time2UTC(DateTime1, UTCtime1)
    call sub_Time2UTC(DateTime2, UTCtime2)
    
    if (all(UTCtime1 == UTCtime2)) return
    
    call sub_UTCtime2msTime(UTCtime1, msTime1)
    call sub_UTCtime2msTime(UTCtime2, msTime2)
    
    msUsedTime = msTime2 - msTime1
    
    return
    end subroutine sub_msUsedTime    
    
    
    ! 将当地时间转换成UTC时间
    subroutine sub_Time2UTC(DateTime, UTCtime)
    implicit none
    integer(kind=4), intent(in):: DateTime(8)    
    integer(kind=4), intent(out):: UTCtime(8)

    integer(kind=4):: YY, Mo, DD, zone, hh, mm, ss, ms, mmTotal, UTCmmTotal, DDoffset
    
    UTCtime = DateTime
    if (DateTime(4) == 0) return
    UTCtime(4) = 0
    
    YY = DateTime(1)
    Mo = DateTime(2)
    DD = DateTime(3)
    zone = DateTime(4)
    hh = DateTime(5)
    mm = DateTime(6)
    
    
    mmTotal = hh * 60 + mm
    UTCmmTotal = mmTotal - zone
    
    if (UTCmmTotal == 0) then
        mm = 0
        hh = 0
        UTCtime(5) = hh
        UTCtime(6) = mm
        return
    else if (UTCmmTotal > 0) then
        mm = mod(UTCmmTotal, 60)
        hh = UTCmmTotal / 60
        UTCtime(5) = hh
        UTCtime(6) = mm
        DDoffset = hh / 24
        if (DDoffset == 0) then
            return
        else
            hh = hh - 24
            DD = DD + 1
            UTCtime(5) = hh
        end if
    else
        DD = DD - 1
        UTCmmTotal = UTCmmTotal + 24 * 60
        mm = mod(UTCmmTotal, 60)
        hh = UTCmmTotal / 60
        UTCtime(5) = hh
        UTCtime(6) = mm
    end if
    
    call sub_adjustDate(YY, Mo, DD)
    UTCtime(1) = YY
    UTCtime(2) = Mo
    UTCtime(3) = DD
    
    return
    end subroutine sub_Time2UTC
    
    
    ! 修正日期, 未考虑初始日期不规范的问题。
    subroutine sub_adjustDate(YY, Mo, DD)
    implicit none
    integer(kind=4), intent(inout):: YY, Mo, DD
    
    integer(kind=4):: dateINmonth(12) = (/ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 /)
    
    if (((mod(YY, 4) == 0) .and. (mod(YY, 100) /= 0)) .or. (mod(YY, 400) == 0)) dateINmonth(2) = 29
    
    if (DD < 1) then
        Mo = Mo - 1
        if (Mo < 1) then
            YY = YY - 1
            Mo = 12
            DD = 31
            return
        else
            DD = dateINmonth(Mo)
            return
        end if
    end if
    
    if (DD > dateINmonth(Mo)) then
        Mo = Mo + 1
        DD = 1
        if (Mo > 12) then
            YY = YY + 1
            Mo = 1
            return
        end if
        return
    end if
    
    return
    end subroutine sub_adjustDate
    
    
    ! 从(+00:00 2026/01/01 00:00:00.000)开始计算
    subroutine sub_UTCtime2msTime(UTCtime, msTime)
    implicit none 
    integer(kind=4), intent(in):: UTCtime(8)
    integer(kind=8), intent(out):: msTime
    
    integer(kind=4):: dateINmonth(12) = (/ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 /)
    integer(kind=4):: YY, Mo, DD, zone, hh, mm, ss, ms, i
    integer(kind=8):: int8hh, int8mm, int8ss
    
    YY = UTCtime(1)
    Mo = UTCtime(2)
    DD = UTCtime(3)
    zone = UTCtime(4)
    hh = UTCtime(5)
    mm = UTCtime(6)
    ss = UTCtime(7)
    ms = UTCtime(8)
    
    if (((mod(YY, 4) == 0) .and. (mod(YY, 100) /= 0)) .or. (mod(YY, 400) == 0)) dateINmonth(2) = 29

    do i = 1, (Mo - 1), 1
        DD = DD + dateINmonth(i)
    end do
    
    do i = 2026, (YY - 1), 1
        if (((mod(i, 4) == 0) .and. (mod(i, 100) /= 0)) .or. (mod(i, 400) == 0)) then
            DD = DD + 366
        else
            DD = DD + 365
        end if
    end do
    
    int8hh = DD * 24 + hh
    int8mm = int8hh * 60 + mm
    int8ss = int8mm * 60 + ss
    msTime = int8ss * 1000 + ms
    
    return
    end subroutine sub_UTCtime2msTime
        
        
        
        !subroutine sub_isMatch(s, p, isornot)
        !implicit none
        !character(len=*), intent(in):: s, p
        !logical(kind=4), intent(out):: isornot
        !
        !integer(kind=4):: i, j, plen, slen, k, i1
        !character(len=1):: si, pj, pjp, sip
        !
        !isornot = .true.
        !slen = len(s)
        !plen = len(p)
        !
        !i = 1
        !j = 1
        !do while ((i < slen) .and. (j < plen))
        !    si = s(i : i)
        !    sip = s(i+1 : i+1)
        !    pj = p(j : j)
        !    pjp = p(j+1 : j+1)
        !    if (pj == '.') then
        !        if (pjp == '*') then
        !            j = j + 2
        !            if(j <= plen) then
        !                pj = p(j:j)
        !                do k = i, slen, 1
        !                    if (pj == s(k:k)) i1 = k
        !                end do
        !            end if
        !            i = i1
        !        else                    
        !            i = i + 1
        !            j = j + 1
        !        end if                
        !    else if(pj == si) then
        !        if (pjp == '*') then              
        !            do while (si == sip)
        !                i = i + 1
        !                sip = s(i:i)
        !            end do
        !            j = j + 2
        !            cycle
        !        else 
        !            i = i + 1
        !            j = j + 1
        !            cycle
        !        end if
        !    else
        !        isornot = .false.
        !        return
        !    end if
        !end do
        !if ((i <= slen) .and. (j <= plen)) then
        !    si = s(i : i)
        !    pj = p(j : j)
        !    if ((pj == '.') .or. (pj == si)) then
        !        i = i + 1
        !        j = j + 1
        !    else
        !        isornot = .false.
        !        return
        !    end if
        !end if
        !if ((i <= slen) .or. (j <= plen)) then
        !    isornot = .false.
        !    return
        !end if
        !
        !
        !return
        !end subroutine sub_isMatch



    !implicit none
    !character(len=256):: dirname = "dir01/"    
    !call sub_mkdir(dirname)
    !integer(kind=4):: zone = 0
    !character(len=6):: str_zone
    !call sub_zone2str(zone, str_zone)
    !character(len=32):: str_DateTime
    !call sub_DateTime2str(str_DateTime)
    !print *, str_DateTime
    
    !character(len=12):: char_date, char_time, char_zone
    !integer(kind=4):: DateTime(8)
    !integer(kind=8):: msUTCtime
    !call date_and_time(char_date, char_time, char_zone, DateTime)
    !call sub_DateTime2msUTCtime(DateTime, msUTCtime)
    !character(len=12):: char_date, char_time, char_zone
    !integer(kind=4):: DateTime1(8), DateTime2(8), i
    !integer(kind=8):: msUsedTime
    !call date_and_time(char_date, char_time, char_zone, DateTime1)
    !call date_and_time(char_date, char_time, char_zone, DateTime2)
    !call sub02_msUsedTime(DateTime1, DateTime2, msUsedTime)
    
    !integer(kind=4):: DateTime(8)
    !integer(kind=8):: msTime = 86400000*1000-1
    !call sub_msTime2DateTime(msTime, DateTime)
    !character(len=12):: char_date, char_time, char_zone
    !integer(kind=4):: DateTime1(8), DateTime2(8)
    !integer(kind=8):: msUsedTime
    !character(len=35):: str_msTime
    !call date_and_time(char_date, char_time, char_zone, DateTime1)
    !call date_and_time(char_date, char_time, char_zone, DateTime2)
    !call sub02_msUsedTime(DateTime1, DateTime2, msUsedTime)
    !call sub_msTime2str(msUsedTime, str_msTime)
    
    !character(len=256):: DirName = "dir01/", LogName = "log.txt", str = ' '
    !call sub_mkdir(DirName)
    !LogName = trim(DirName) // trim(LogName)
    !str = "第一行记录"
    !call sub_Logging(LogName, str)
    !str = "第二行记录"
    !call sub_Logging(LogName, str)
    
    !integer(kind=4):: nums(4) = (/ 1, 2, 3, 4 /), targ = 3, inde(2)
    !call sub_twosum(size(nums), nums, targ, inde)
    !use mod_LeeCode0001
    !integer(kind=4):: l1(7) = (/ 9, 9, 9, 9, 9, 9, 9 /), l2(4) = (/ 9, 9, 9, 9 /)
    !integer(kind=4), allocatable:: l3(:)
    !call sub_addTwoNumbers(size(l1), l1, size(l2), l2, l3)
    
    !use mod_LeeCode0001
    !character(len=6):: s = "pwwkew"
    !integer(kind=4):: n
    !call sub_lengthOfLongestSubstring(s, n)
    !print *, n
    
    !use mod_LeeCode0001
    !integer(kind=4):: nums1(5) = (/ 1, 4, 5, 6, 7/), nums2(2) = (/ 2, 3 /)
    !real(kind=8):: mid
    !call sub_findMedianSortedArrays(size(nums1), nums1, size(nums2), nums2, mid)
    !print *, mid
    
    !use mod_LeeCode0001
    !character(len=256):: s = 'cbbd'
    !character(len=:), allocatable:: subPs
    !
    !call sub_longestPalindrome(trim(s), subPs)
    !print *, subPs
    
    !use mod_LeeCode0001
    !character(len=256):: s = 'PAYPALISHIRING', sNew = ' '
    !integer(kind=4):: numRows = 4
    !
    !call sub_convert(trim(s), numRows, sNew)
    !print *, trim(sNew)
    
    !use mod_LeeCode0001
    !integer(kind=4):: x = -huge(1)-1, xr
    !call sub_reverse(x, xr)
    !print *, xr
    
    !use mod_LeeCode0001
    !character(len=200):: s1 = "42"
    !character(len=200):: s2 = " -042"
    !character(len=200):: s3 = "1337c0d3"
    !character(len=200):: s4 = "0-1"
    !character(len=200):: s5 = "words and 987"
    !integer(kind=4):: x
    !call sub_myAtoi(s1, x)
    !print *, x
    !call sub_myAtoi(s2, x)
    !print *, x
    !call sub_myAtoi(s3, x)
    !print *, x
    !call sub_myAtoi(s4, x)
    !print *, x
    !call sub_myAtoi(s5, x)
    !print *, x
    
    !use mod_LeeCode0001
    !integer(kind=4):: x = 1234
    !logical(kind=4):: ISorNOT
    !call sub_isPalindrome(x, ISorNOT)
    !print *, ISorNOT
    
    ! 123453453334
    ! 好难，aaaaa
    !use mod_LeeCode0001
    !character(len=256):: s = '123asf123', p = '.*123'
    !logical(kind=4):: isMatch
    !call sub_isMatch(trim(s), trim(p), isMatch)
    !print *, isMatch